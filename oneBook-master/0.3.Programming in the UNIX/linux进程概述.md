linux进程相关
---

[TOC]


### 程序开始和结束

> 程序上来是不能直接运行main函数，需要有个汇编阶段的引导代码

main函数由谁调用：

程序开始运行是由谁来把它拿去调用呢？之前在学编程语言的时候main函数是整个函数的起始入口点，main函数的开始就是程序的开始，main函数的结尾就是程序的结尾。但是main函数是由谁所执行谁所调用的呢？之前说main是由系统调用的，但是这种说法并不准确。回忆裸机编程，当时没有操作系统，程序上来是不能直接写个C语言写个main的，需要有个汇编阶段的引导代码，也就是裸机阶段的start.S

在操作系统里面其实也是需要一段引导代码的，只不过这段代码不需要自己写，而是由操作系统提供，是编译器在编译链接的时候帮我们叠加上去，代码也比之前裸机写的start.S复杂

另外，编译器在编译链接的时候帮我们把引导程序叠加上去，那么是如何叠加上去的呢？**链接脚本**。这个链接脚本可以自己自己写，也可以使用系统提供的默认链接脚本

编译链接之后生成一个可执行文件，系统怎么去执行呢？运行时的加载器。加载器是操作系统中的程序，当去执行一个程序时（譬如./a.out，譬如代码中用exec族函数来运行）加载器负责将这个程序加载到内存中去执行这个程序。argc和argv的传参的实现也是依靠加载器来实现。

总结：程序在编译连接时用**链接器**，运行时用**加载器**，这两个东西对程序运行原理非常重要



### linux进程环境

1. 环境变量

(1)export命令查看环境变量<br>
(2)进程环境表。每一个进程中都有一份所有环境变量构成的一个表格，即当前进程中可以直接使用这些环境变量。`进程环境表其实是一个字符串数组`，用environ变量指向它<br>
(3)程序中通过`environ全局变量`使用环境变量。程序可以无条件直接使用系统中的环境变量，一旦程序中用到了环境变量那么程序就和操作系统环境有关<br>
```c
    extern char **environ; 
    //只要声明就可以。不用另外定义。二重指针，因为是字符串数组
    int i = 0;
	while (NULL != environ[i]){
		printf("%s\n", environ[i]);
		i++;
	}
```
(4)获取指定环境变量函数getenv

    char *getenv(const char *name);

2. 进程运行的虚拟地址空间

意义：进程隔离，提供多进程同时运行；RTOS没有虚拟地址，里面的程序叫任务不叫进程


### linux进程控制



#### 1. 进程的正式引入

(1)进程控制块PCB（process control block）内核中专门用来管理一个进程的结构体<br>
(2)进程ID<br>
(3)多进程调度原理


#### 2. fork创建子进程

(1)为什么要创建子进程

    每一次程序的运行都需要一个进程
    多进程实现宏观上的并行
(2)fork的内部原理

    a.进程的分裂生长模式。如果操作系统需要一个新进程来运行一个程序，那么操作系统会用一个现有的进程来复制生成一个
    新进程。旧进程叫父进程，复制生成的新进程叫子进程
    b.fork函数调用一次会返回2次，为什么要返回两次？fork后会创建一个子进程，那么加上父进程总共就两个，返回值等于0
    的就是子进程，而返回值大于0的就是父进程
    c.典型的使用fork的方法：使用fork后然后用if判断返回值，并且返回值大于0时就是父进程，等于0时就是子进程
    d.fork的返回值在子进程中等于0，在父进程中等于本次fork创建的子进程的进程ID

#### 3. 父子进程一起操作同一文件情况谈论

    ...

#### 4. 进程的诞生和消亡

(1)进程的诞生

    进程0和进程1：第一个进程也就是进程0，在操作系统内核里面。内核在启动的过程中手工构建起来，即进程0的进程控制块
    PCB是由内核一点一点的添加出来的。进程1是进程0fork而来的，只不过当时的进程1还是在内核态下，并不是在应用程序下
    fork做的，即是在内核底下用内部的fork直接由进程0 fork进程1.然后进程1再调用用户态下的init进程
    
(2)进程的消亡

    a.正常终止和异常终止
    b.进程在运行时需要消耗系统资源（内存、IO等），进程终止时应完全释放这些资源。另外，意外终止也会造成资源不能正
    常释放，所以设计的时候也要考虑到这种情况
    c.linux系统设计时规定：每一个进程退出时，操作系统会自动回收这个进程涉及到的所有的资源（譬如malloc申请的内容没
    有free时，当前进程结束时这个内存会被释放，譬如open打开的文件没有close的在程序终止时也会被关闭）。但操作系统只
    是回收了这个进程工作时消耗的内存和IO，而并没有回收这个进程本身占用的内存（8KB，主要是task_struct和栈内存，不
    是这个整个进程大小，如果这样设计那进程要是很大内存是不够用的）
    d.因为进程本身的8KB内存操作系统不能回收需要别人来辅助回收，因此每个进程都需要一个帮助它收尸的人，这个人就是这
    个进程的父进程
    
(3)僵尸进程

    a.子进程先于父进程结束。子进程结束后父进程并不一定立即能帮子进程“收尸”，在这一段时间（子进程已经结束且父进程
    尚未帮其收尸）子进程就成为僵尸进程
    b.子进程除task_struct和栈外其余内存空间皆已清理（不要再以为是整个程序）
    c.父进程可以使用wait或waitpid以显式回收子进程的剩余待回收内存资源并且获取子进程退出状态(子进程是否异常退出)
    d.父进程可以不使用wait或者waitpid回收子进程，此时父进程结束时一样会回收子进程的剩余待回收内存资源。（这样设计
    是为了防止父进程忘记显式调用wait/waitpid来回收子进程从而造成内存泄漏）

(4)孤儿进程

    父进程先于子进程结束，子进程成为一个孤儿进程。linux系统规定：所有的孤儿进程都自动成为一个特殊进程（进程1，也
    就是init进程）的子进程

#### 5. 父进程wait回收子进程/waitpid介绍

子进程结束时，系统向其父进程发送SIGCHILD信号。父进程调用wait函数后阻塞，等待子进程发来结束信号。（信号：父子进程之间是异步的，信号机制就是为了解决异步通信问题）


#### 6. exec族函数

> 详细内容可以网上找些内容过来看或者看书，虽然很重要但这里不再赘述

exec族的6个函数介绍：

(1)execl和execv 	

    int execl(const char *path, const char *arg, ...);.                                         
    int execv(const char *path, char *const argv[]);    //注意const 的位置    
这两个函数是最基本的exec，都可以用来执行一个程序，区别是传参的格式不同。execl是把参数列表（本质上是多个字符串，必须以NULL结尾）依次排列而成（l其实就是list的缩写），execv是把参数列表事先放入一个字符串数组中，再把这个字符串数组传给execv函数。

(2)execlp和execvp	

    int execlp(const char *file, const char *arg, ...);                                         
    int execvp(const char *file, char *const argv[]);   
    
这两个函数在上面2个基础上加了p，较上面2个来说，区别是：上面2个执行程序时必须指定可执行程序的全路径（如果exec没有找到path这个文件则直接报错），而加了p的传递的可以是file（也可以是path，只不过兼容了file。加了p的这两个函数会首先去找file，如果找到则执行执行，如果没找到则会去环境变量PATH所指定的目录下去找，如果找到则执行如果没找到则报错）

(3)execle和execvpe	

    int execle(const char *path, const char *arg,..., char * const envp[]);                        
    int execvpe(const char *file, char *const argv[],char *const envp[]);.  
这两个函数较基本exec来说加了e，函数的参数列表中也多了一个字符串数组envp形参，e就是environment环境变量的意思，和基本版本的exec的区别就是：执行可执行程序时会多传一个环境变量的字符串数组给待执行的程序。


#### 7. 进程状态和system函数

进程的5种状态：

(1)就绪态。这个进程当前所有运行条件就绪，只要得到了CPU时间就能直接运行

    就绪态链表 进程链表
(2)运行态。处于就绪态时的进程得到了CPU就进入运行态开始运行
(3)僵尸态。进程已经结束但是父进程还没来得及回收
(4)等待态（浅度睡眠&深度睡眠），进程在等待某种条件，条件成熟后可进入就绪态。浅度睡眠等待时进程可以被（信号）唤醒，而深度睡眠等待时不能被唤醒只能等待的条件到了才能结束睡眠状态

    浅度睡眠被唤醒有两种情况 一种是等到了，另外一种是没等到，不等了然后该干嘛干嘛  
(5)暂停态。暂停并不是进程的终止，只是被被人（信号）暂停了，还可以恢复的

![](https://raw.githubusercontent.com/TongxinV/oneBook/master/0.3.Programming%20in%20the%20UNIX/assets/%E8%BF%9B%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81.png)

system函数简介:

(1)system函数 = fork+execp  区别是system函数是原子操作<br>
(2)原子操作。原子操作意思就是整个操作一旦开始就会不被打断的执行完。原子操作的好处就是不会被人打断（不会引来竞争状态），坏处是自己单独连续占用CPU时间太长影响系统整体实时性，因此应该尽量避免不必要的原子操作，就算不得不原子操作也应该尽量原子操作的时间缩短



### linux进程关系

(1)无关系<br>
(2)父子进程关系<br>
(3)进程组（group）由若干进程构成一个进程组。为什么要有进程组，说白了就是为了让这个组的进程之间的关系比和别的进程的关系更亲近一些<br>
(4)会话（session）会话就是进程组的组<br>


### linux守护进程

> 学守护进程并不是为了只为了学习这个守护进程。学习这个东西的过程会用到很多东西，把这些东西学会了之后也能够做别的一些事情

1. 何谓守护进程

(1)daemon，表示守护进程，简称为d（进程名后面带d的基本就是守护进程）<br>
(2)长期运行（一般是开机运行直到关机时关闭）<br>
(3)与控制台脱离（普通进程都和运行该进程的控制台相绑定，表现为如果终端被强制关闭了则这个终端中运行的所有进程都被会关闭，背后的问题还在于会话）<br>
(4)服务器（Server），服务器程序就是一个一直在运行的程序，可以提供某种服务（譬如nfs服务器提供nfs通信方式），当程序需要这种服务时可以调用服务器程序（和服务器程序通信以得到服务器程序的帮助）来进程这种服务操作。服务器程序一般都实现为守护进程<br>

可以这样理解：守护进程就是一种特殊的进程，这种进程的特点就是跟控制台完全脱离，所以这个守护进程能够独立于控制台长期的稳定运行。长期的运行是为了给其他进程提供某种服务，当别人需要某种服务的时候就会去和守护进程通讯以得到他的帮助。这就是操作系统设计的一种进程叫守护进程

2. 常见守护进程（当然自己也可以实现守护进程）

```
守护进程是用户进程，跟内核没有关系，守护进程还是在应用程序上面做出来的东西，他只是一个不会被关闭的应用程序
```
(1)syslogd，系统日志守护进程，提供syslog功能<br>
(2)cron，cron进程用来实现操作系统的时间管理，linux中实现定时执行程序的功能就要用到cron<br>

3. 编写简单守护进程

create_daemon函数要素(实现的步骤)：

(1)子进程等待父进程退出。fork后父进程也有一份子进程的代码，所以实现守护进程<br> 父进程一定要在在子进程那部分代码前面结束<br>
(2)子进程使用setsid创建新的会话期，脱离控制台<br>
(3)调用chdir将当前工作目录设置为/<br>
(4)umask设置为0以取消任何文件权限屏蔽<br>
(5)关闭所有文件描述符<br>
(6)将0、1、2定位到/dev/null <br>

![](https://raw.githubusercontent.com/TongxinV/oneBook/master/0.3.Programming%20in%20the%20UNIX/assets/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B.png)

4. 使用syslog来记录调试信息

> 我们在写了一个create_deamon函数在之后，创建了一个守护进程的程序。守护进程因为关闭了0、1、2，关闭了所有文件描述符，并且把0/1/2定位到了/dev/null，所以守护进程是不能够向控制台去输出信息，而且他也已经跟控制台没有关系了。所以无法通过控制台通过printf去打印信息的。那么他如何向用户输出信息的呢？方法就是通过syslog来写日志信息

(1)openlog、syslog、closelog
```
    ...
```
(2)syslog的工作原理

    a.操作系统中有一个守护进程syslogd（开机运行，关机时才结束），这个守护进程syslogd负责进行日志文件的写入和维护
    b.syslogd是独立于任意一个进程而运行的。当前进程和syslogd进程本来是没有任何关系的，但是当前进程可以通过调用
    openlog打开一个和syslogd相连接的通道，然后通过syslog向syslogd发消息，然后由syslogd来将其写入到日志文件系统中
    c.syslogd其实就是一个日志文件系统的服务器进程，提供日志服务。任何需要写日志的进程都可以通过openlog/syslog/
    closelog这三个函数来利用syslogd提供的日志服务来进行相关操作。这就是操作系统的服务式的设计
    
服务式的设计，操作系统有很多的服务器，像ftp守护进程等。通过这部分内容第一：学会syslog能够通过syslog写日志来进    行一些程序的调试和一些信息的记录；第二：能够理解syslogd的存在，能够明白守护进程的作用，能够初步理解服务，也能    够理解操作系统设计服务这种机制的理念
    
5. 让程序不能被多次运行

(1)问题：因为守护进程是长时间运行而不退出，因此./a.out执行一次就有一个进程，执行多次就有多个进程。这并不是我们想要的

(2)实现方法：最常用的一种方法就是：用一个文件的存在与否来做标志。具体做法是程序在执行之初去判断一个特定的文件是否存在，若存在则标明进程已经在运行，若不存在则标明进程没有在运行。然后运行程序时去创建这个文件，当程序结束的时候去删除这个文件即可

![](https://raw.githubusercontent.com/TongxinV/oneBook/master/0.3.Programming%20in%20the%20UNIX/assets/%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1.png)

### linux进程通信（IPC）

> 不概述了，这里就不写基本的一些内容了。而且日常使用少，只有大型程序才能用上；更为复杂，属于linux应用编程中难度最大的部分

1. linux内核提供多种进程间通信机制	四类

(1)无名管道和有名管道<br>
(2)SystemV IPC：信号量、消息队列、共享内存<br>
(3)域套接字Socket<br>
(4)信号<br>

2. 剩余内容看书网上找资料



