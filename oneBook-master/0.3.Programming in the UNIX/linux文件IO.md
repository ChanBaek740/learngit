linux文件I/O 
---


[TOC]

* `linux文件I/O`
    * `文件I/O`
        * `Linux文件操作过程`
        * `打开关闭文件open/close`
        * `关于open函数flags`
        * `读写文件内容read/write`
        * `文件读写的一些细节`
        * `linux系统如何管理文件`
        * `文件共享的实现方式(3)`
    * `文件属性`
        * `linux各种文件类型`
        * `常用文件属性获取`
        * `文件权限管理`
        * `读取目录文件`



### 文件I/O

> IO就是input/output，文件IO的意思就是读写文件。常用文件IO接口：open、close、write、read、lseek

#### Linux文件操作过程

(1)在linux系统中要操作一个文件，一般是先open打开一个文件，得到一个文件描述符，然后对文件进行读写操作（或其他操作），最后close关闭文件即可<br>
(2)文件平时是存在**块设备**中的文件系统中的，称为静态文件。当open打开一个文件时，linux内核做的操作包括：a.内核在进程中建立了一个打开文件的数据结构，记录下打开的这个文件；b.内核在内存中申请一段**内存**，并且将静态文件的内容从块设备中读取到内存中特定地址管理存放（叫动态文件）<br>
(3)打开文件后，以后对这个文件的读写操作，都是`针对内存中这一份动态文件`的，而不是针对静态文件。对动态文件进行读写时，内存中的动态文件和块设备中的静态文件不同步，close关闭动态文件时，close内部实现才会将内存中的动态文件的内容更新（同步）到块设备中的静态文件

**为什么要这么设计？**
因为块设备本身有读写限制（搜索NnadFlash、SD等块设备的读写特征），本身对块设备进行操作非常不灵活。而内存可以按字节为单位来操作，而且可以随机操作（内存就叫RAM，random），很灵活。所以内核设计文件操作时就这么设计了

#### 打开关闭文件open/close

**open/close**：

    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);
    
    
##### 关于open函数flags

(1)读写权限：`O_RDONLY` `O_WRONLY` `O_RDWR`

(2)打开存在并有内容的文件时：`O_APPEND(追加)`、`O_TRUNC(覆盖)`

(3)打开不存在的文件时：`O_CREAT`、`O_EXCL`

    当open打开一个文件时如果这个文件名不存在则会打开文件错误。open的flag<O_CREAT>就是为了应对这种打开一个并不存在
    文件，O_CREAT就表示当前打开的文件不存在时创建并且打开它
    
    思考：当open使用了O_CREAT，但是文件已经存在的情况下会怎样？open中加入O_CREAT后，不管原来这个文件存在与否都能
    打开成功，如果原来文件不存在则创建一个空的新文件，如果原来这个文件存在则会重新创建这个文件，原来的内容会被消
    除掉（类似于先删除原来的文件再创建一个新的）
    这样可能带来一个问题？本来是想去创建一个新文件的，但是把文件名搞错了弄成了一个已存在文件名，结果该文件就被意
    外修改，很危险。希望的效果是：如果CREAT要创建的是一个已经存在的名字的文件，则报错，不要去创建这个效果就要靠
    O_EXCL标志和O_CREAT标志来结合使用。当这连个标志一起的时候，则没有文件时创建文件，有这个文件时会报错提醒
    
(4)阻塞与非阻塞：`O_NONBLOCK`（只用于设备文件，而不用于普通文件）

    只用于设备文件，而不用于普通文件
(5)阻塞等待底层完成写入才返回到应用层：`O_SYNC`

    无O_SYNC时write只是将内容写入底层缓冲区即可返回，然后底层（操作系统中负责实现open、write这些操作的那些代码，
    也包含OS中读写硬盘等底层硬件的代码）在合适的时候会将buf中的内容一次性的同步到硬盘中。这种设计是为了提升硬件操
    作的性能和销量，提升硬件寿命；但是有时候希望硬件不要等待，直接将内容写入硬盘中，这时候就可以用O_SYNC标志



#### 读写文件内容read/write

**read/write**：
    ssize_t read(int fd, void *buf, size_t count);
    ssize_t write(int fd, const void *buf, size_t count);


##### 文件读写的一些细节

(1)read和write的count

    a. count和返回值的关系。count参数表示想要写或者读的字节数，返回值表示实际完成的要写或者读的字节数。实现的有可
    能等于想要读写的，也有可能小于（说明没完成任务）
    b. count再和阻塞非阻塞结合起来，就会更加复杂。如果一个函数是阻塞式的，假设要读取30个，结果暂时只有20个时就会
    被阻塞住，等待剩余的10个可以读，如果不做相应处理就一直卡在这里。举个例子...
    注：打开一个设备文件默认就是阻塞式打开
    c. 有时候写正式程序时，要读取或者写入的是一个很庞大的文件（譬如文件有2MB），不可能把count设置为2*1024*1024，
    而应该把count设置为一个合适的数字（譬如2048、4096），然后通过多次读取来实现全部读完。可以通过设置循环，看每一
    次读回来的是不是2048，如果是说明没读完；如果不到2048.说明文件已经被读完了，剩下的不到2048

(2)文件IO效率和标准IO

    文件IO就指的是我们当前在讲的open、close、write、read等API函数构成的一套用来读写文件的体系，这套体系可以很好的
    完成文件读写，但是效率并不是最高的
    应用层C语言库函数提供了一些用来做文件读写的函数列表，叫标准IO。标准IO由一系列的C库函数构成（fopen、fclose、fw
    rite、fread），这些标准IO函数其实是由文件IO封装而来的（fopen内部其实调用的还是open，fwrite内部还是通过write来
    完成文件写入的）。标准IO加了封装之后主要是为了在应用层添加一个缓冲机制...一趟送一个跟一趟一小车的区别
    
    
(3)多次打开同一文件与O_APPEND

    重复打开同一（普通）文件读取...
    重复打开同一（普通）文件写入...
    
#### linux系统如何管理文件

> 学习linux如何管理文件的基本原理，从根本上来理解操作系统是如何来管理文件的。学习这些东西有什么用呢？可以继续学习linux中关于文件操作更复杂的一些更高级的一些内容。某些更高的应用需要你对操作系统对文件的管理的策略有点了解之后，才能更加深入的理解。这部分内容看起来更像是一节没用的理论课，但实际上对理解具体的操作的内部的原理是非常有帮助，而且能让文件操作能和其他知识点关联起来。所以不要轻视这部分内容

(1)硬盘中的静态文件和inode（i节点）
    
    ...
(2)内存中被打开的文件和vnode（v节点）

    ...
(3)文件与流的概念

    流（stream）对应自然界的水流。文件操作中，文件类似是一个大包裹，里面装了一堆字符，但是文件被读出/写入时都只能
    一个字符一个字符的进行，而不能一股脑儿的读写，那么一个文件中N多的个字符被挨个一次读出/写入时，这些字符就构成
    了一个字符流




#### 文件共享的实现方式(3)

> 文件共享的核心就是怎么弄出来多个文件描述符指向同一个文件

什么是文件共享：

(1)文件共享就是同一个文件（同一个文件指的是同一个inode，同一个pathname）被多个独立的读写体（可以理解为多个文件描述符fd）去同时（一个打开尚未关闭的同时另一个去操作）操作

(2)文件共享的意义有很多：为什么要共享文件？譬如可以通过文件共享来实现多线程同时操作同一个大文件，以减少文件读写时间，提升效率。例如迅雷下载，修高速公路多段同时开修

文件共享的3种实现方式：

(1)同一个进程中多次使用open打开同一个文件<br>
(2)不同进程中去分别使用open打开同一个文件<br>   
(3)使用dup/dup2 API来让进程复制文件描述符<br>


### 文件属性

> Linux里面有各种各样的文件类型，为什么要有不同的文件类型呢？在linux里面有一句话：一切皆是文件，一切皆是文件这种设计方法应该是为了简化系统，客观来讲，linux系统或者说linux在所效仿的unix系统中的一切皆是文件这种设计方式降低了系统的设计难度，而且是一种非常优秀的设计方法，大家现在可能还体会不到


#### linux各种文件类型

(1)普通文件     （-	regular file）<br>
(2)目录文件     （d	directory）<br>
(3)字符设备文件 （c	character）<br>
(4)块设备文件   （b	block）<br>
(5)管道文件     （p pipe）<br>
(6)套接字文件   （s	socket）<br>
(7)符号链接文件 （l	link）<br>

#### 常用文件属性获取

> stat、fstat、lstat函数

#### 文件权限管理


(1)st_mode中记录的文件权限位<br>
(2)ls -l打印出的权限列表(user、group、others)<br>
(3)access函数检查权限设置<br>
(4)chmod/fchmod与权限修改<br>
(5)chown/fchown/lchown与属主修改<br>
(6)umask与文件权限掩码<br>


#### 读取目录文件

> opendir与readdir函数

略
